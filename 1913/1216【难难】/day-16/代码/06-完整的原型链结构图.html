<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        var Person = function() {}
        var p1 = new Person();

        /* Person是构造函数，是函数，是特殊的对象 */
        /* Person是对象，Person也有自己的构造函数  函数的构造函数都是Function */
        console.log(Person.constructor == Person.__proto__.constructor, Person.constructor == Function); /* true true */
        console.log(Person.__proto__ == Function.prototype, Person.__proto__); //true ƒ () { [native code] }

        /* Object是内置的构造函数，是函数，是对象，也有构造函数。 */
        console.log(Object.__proto__ == Function.prototype);
        console.log(Object.prototype.__proto__ == Object.prototype);

        /* 推论：错误(死循环) */
        console.log(Function.prototype.__proto__ == Function.prototype);
        console.log(Function.prototype.__proto__ == Object.prototype);
        console.log(Function.__proto__ == Function.prototype);


        /* 原型链 */
        /* ①  p1->Person.prototype->Object.prototype->null */
        /* ②  Person->Function.prototype->Object.prototype->null*/
        /* ③  Function->Function.prototype->Object.prototype->null */
        /* ④  Object->Function.prototype->Object.prototype->null */


        /* 访问规则 */
        /* 当对象在访问属性和方法的时候，会优先在自己身上查找，如果找到那么就直接使用 */
        /* 如果没有找到那么就查找自己的原型对象，如果在原型对象上面找到那么就直接使用，如果没有找到那么就继续查找上一层原型对象 */
        /* ...重复这个过程 */
        /* 直到找到为止，如果找到了原型链的顶点(Object.prototype)还没有找到，那么属性就返回undefined，方法就报错。 */
    </script>
</body>

</html>